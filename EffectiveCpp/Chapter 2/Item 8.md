# Item 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

소멸자로부터 예외가 터져 나가면 완전하지 못한 프로그램 종료나 미정의 동작의 원인이 됨

C++는 예외를 내보내는 소멸자를 좋아하지 않음

---

예외를 던지고 실패할 수 있는 코드를 소멸자에 넣어야 한다면?

ex) 데이터베이스 연결

```c++
class DBConnection {
public:
    ...
    static DBConnection create();  // DBConnection 객체 반환
    void close();  // 연결을 닫음. 연결 실패 시 예외 던짐
}

class DBConn {
public:
    ...
    ~DBConn() {
        db.close();
    }

private:
    DBConnection db;
}
```

소멸자에서 close 호출

close 호출 시 예외가 발생했다면 둘 중 하나를 선택할 수 있음

### 프로그램을 바로 끝낸다.

대개 abort를 호출함

```c++
DBConn::~DBConn() {
    try { db.close(); }
    catch (...) {
        // close 호출 실패 로그
        std::abort();
    }
}
```

에러 발생 후 프로그램 실행을 계속할 수 없는 상황이라면 괜찮은 선택

### 예외를 삼켜버린다.

```c++
DBConn::~DBConn() {
    try { db.close(); }
    catch (...) {
        // close 호출 실패 로그
    }
}
```

무엇이 잘못됐는지를 알려주는 정보가 묻혀 버리기 때문에 대부분의 경우 좋은 발상은 아님

발생한 예외를 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 함

둘 다 문제점이 있다.

---

DBConn 인터페이스를 잘 설계해서, 문제에 대처할 기회를 사용자가 가질 수 있도록 하자

DBConn에서 close 함수를 직접 제공하게 하면 함수 실행 중 발생하는 예외를 사용자가 직접 처리할 수 있음

DBConnection이 닫혔는지 여부 유지 → 닫히지 않았으면 DBConn의 소멸자에서 닫기

하지만 소멸자에서 호출하는 close마저 예외가 발생하면 끝내거나 삼켜 버리거나 해야 함

---

어떤 동작이 예외를 일으키면서 실패할 가능성이 있고, 그 예외를 처리해야 할 필요가 있다면, 그 예외는 **소멸자가 아닌 다른 함수에서 비롯된 것이어야 함**

예외를 일으키는 소멸자는 프로그램의 불완전 종료나 미정의 동작의 위험이 있음

사용자에게 에러를 처리할 수 있는 기회를 주는 것

---

**소멸자에서는 예외가 빠져나가면 안 됨**

**만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리든지 프로그램을 끝내든지 해야 함**

**어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 함**

