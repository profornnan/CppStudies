# Item 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

TimeKeeper 클래스를 기본 클래스로 생성 후 적절한 용도에 따라 파생시키기

```c++
class TimeKeeper {
public:
    TimeKeeper();
    ~TimeKeeper();
    ...
};
class AtomicClock: public TimeKeeper { ... };
class WaterClock: public TimeKeeper { ... };
```

**팩토리 함수(factory function)** : 새로 생성된 파생 클래스 객체에 대한 기본 클래스 포인터를 반환하는 함수

```c++
// TimeKeeper에서 파생된 클래스를 통해 동적으로 할당된 객체의 포인터 반환
TimeKeeper* getTimeKeeper();
```

getTimeKeeper 함수에서 반환되는 객체는 힙에 있음 → 자원 누출을 막기 위해 삭제 필요

```c++
TimeKeeper *ptk = getTimeKeeper();
...
delete ptk;
```

getTimeKeeper 함수가 반환하는 포인터는 파생 클래스 객체에 대한 포인터 → 삭제 시 기본 클래스 포인터를 통해 삭제됨

기본 클래스(TimeKeeper)에 들어있는 소멸자가 **비가상 소멸자**임

기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의 사항임 → 그 객체의 파생 클래스 부분이 소멸되지 않음

**가상 소멸자 사용**을 통해 해결 → 객체가 전부 소멸됨

```c++
class TimeKeeper {
public:
    TimeKeeper();
    virtual ~TimeKeeper();
    ...
};
```

가상 함수를 하나라도 가진 클래스는 대부분 가상 소멸자를 가져야 함

가상 소멸자를 갖고 있지 않은 클래스 → 기본 클래스 사용 X

기본 클래스로 의도하지 않은 클래스에 대해 소멸자를 가상으로 선언하는 것은 좋지 않음

가상 함수를 C++에서 구현하려면 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를 결정하는 데 쓰이는 정보 필요 → 가상 함수 테이블 포인터(vptr)

vptr은 가상 함수의 주소를 가리키고 있음

가상 함수 테이블 포인터의 배열은 가상 함수 테이블(vtbl)

클래스에 가상 함수가 들어가면 객체 크기가 커짐

**클래스에 가상 함수가 하나라도 있는 경우에만 가상 소멸자 선언**

string 타입이나 STL 컨테이너 타입 같은 경우 가상 소멸자가 없기 때문에 기본 클래스로 사용 X

---

순수 가상 함수는 해당 클래스를 추상 클래스(그 타입의 객체를 생성할 수 없음)로 만듦

추상 클래스로 만들고 싶은 클래스에 순수 가상 소멸자 선언

```c++
class AWOV {
public:
    virtual ~AWOV() = 0;
};
```

AWOV는 추상 클래스

가상 소멸자 → 소멸자 호출 문제 고민 X

순수 가상 소멸자 정의 필요 → 없으면 링커 에러 발생

```c++
AWOV::~AWOV() {}
```

소멸자 동작 순서 : 가장 말단에 있는 파생 클래스의 소멸자 먼저 호출. 기본 클래스쪽으로 거쳐 올라가며 각 기본 클래스의 소멸자 하나씩 호출

**다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자**

기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도록 설계된 기본 클래스에만 적용됨

모든 기본 클래스가 다형성을 갖도록 설계된 것은 아님

기본 클래스로 쓰일 수 있지만 다형성은 갖지 않도록 설계된 클래스도 있음 → 가상 소멸자 X

---

**다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 함**

**어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 함**

**기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 함**

