# Item 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

복사 생성자, 복사 대입 연산자, 소멸자는 클래스 안에 직접 선언해 넣지 않으면 컴파일러가 저절로 선언해 주도록 되어있음

생성자도 선언되어 있지 않으면 컴파일러가 기본 생성자를 선언함

이들은 모두 public 멤버이며 inline 함수임

```c++
class Empty {};
```

```c++
class Empty {
public:
    Empty() { ... }  // 기본 생성자
    Empty(const Empty& rhs) { ... }  // 복사 생성자
    ~Empty() { ... }  // 소멸자
    Empty& operator=(const Empty& rhs) { ... }  // 복사 대입 연산자
};
```

이들은 꼭 필요하다고 컴파일러가 판단할 때만 만들어짐

이들이 만들어지는 조건은 다음과 같음

```c++
Empty e1;  // 기본 생성자, 소멸자
Empty e2(e1);  // 복사 생성자
e2 = e1;  // 복사 대입 연산자
```

소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상 소멸자로 되어 있지 않으면 비가상 소멸자로 만들어짐

복사 생성자/복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체 쪽으로 복사함

---

생성자가 선언되어 있으면 컴파일러는 기본 생성자를 만들지 않음

---

복사 생성자

표준 string 타입은 자체적으로 복사 생성자 갖고 있음 → string의 복사 생성자에 인자로 넘겨 호출

int는 기본제공 타입 → 각 비트를 그대로 복사

---

복사 대입 연산자

최종 결과 코드가 적법해야(legal)하고 이치에 닿아야 함(reasonable)

둘 중 어느 검사도 통과하지 못하면 컴파일러는 operator=의 자동 생성을 거부함

ex) string에 대한 참조자, 상수(const)

C++의 참조자는 원래 자신이 참조하고 있는 것과 다른 객체를 참조할 수 없음

참조자를 데이터 멤버로 갖고 있는 클래스에서는 직접 복사 대입 연산자 정의

데이터 멤버가 상수인 경우도 비슷하게 동작

상수 멤버를 수정하는 것은 문법에 어긋남

복사 대입 연산자를 private로 선언한 기본 클래스로부터 파생된 클래스의 경우, 이 클래스의 암시적 복사 대입 연산자를 가질 수 없음

---

**컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있음**

