# Item 36: 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물!

```c++
class B {
public:
    void mf();
    ...
};

class D: public B { ... };
```

```c++
D x;

B *pB = &x;
pB->mf();

D *pD = &x;
pD->mf();
```

양쪽의 경우에서 x 객체로부터 mf 멤버 함수 호출

함수도 똑같고 객체도 똑같으니, 동작도 같아야 하는게 맞지만 다를 수도 있다는 게 문제

특히, mf가 비가상 함수이고 D 클래스가 자체적으로 mf 함수를 또 정의하고 있는 경우

```c++
class D: public B {
public:
    void mf();  // B::mf를 가려버림. Item 33 참고
    ...
};

pB->mf();  // B::mf 호출
pD->mf();  // D::mf 호출
```

이렇게 두 얼굴의 동작을 하는 이유는, B::mf 및 D::mf 등의 비가상 함수는 정적 바인딩(static binding)으로 묶이기 때문 → Item 37 참고

pB는 B에 대한 포인터 타입으로 선언되었기 때문에, pB를 통해 호출되는 비가상 함수는 항상 B 클래스에 정의되어 있을 것이라고 결정해 버림

B에서 파생된 객체를 pB가 가리키고 있다 해도 마찬가지

---

가상 함수의 경우엔 동적 바인딩(dynamically binding)으로 묶임 → Item 37 참고

만약 mf 함수가 가상 함수였다면, mf가 pB에서 호출되든 pD에서 호출되든 D::mf가 호출됨

pB 및 pD가 진짜로 가리키는 대상은 D 타입의 객체

---

D 클래스를 만드는 도중에 B 클래스로부터 물려받은 비가상 함수인 mf를 재정의해 버리면, D 클래스는 일관성 없는 동작을 보이는 이상한 클래스가 됨

---

public 상속의 의미는 "is-a(...는 ...의 일종이다)" → Item 32 참고

비가상 멤버 함수는 클래스 파생에 관계없는 불변동작을 정해 두는 것 → Item 34 참고

- B 객체에 해당되는 것들이 D 객체에 그대로 적용됨. 모든 D 객체는 B 객체의 일종이기 때문
- B에서 파생된 클래스는 mf 함수의 인터페이스와 구현을 모두 물려받게 됨. mf는 B 클래스에서 비가상 멤버 함수이기 때문

D에서 mf를 재정의하는 순간 설계에 모순이 생김

---

어떤 상황에서도 상속받은 비가상 함수를 재정의하는 것은 절대 금물

---

Item 7의 내용은 이번 항목의 특수한 한 경우

다형성을 부여한 기본 클래스의 소멸자를 반드시 가상 함수로 만들어 두어야 하는 이유

---

**상속받은 비가상 함수를 재정의하는 일은 절대로 하지 말자**

