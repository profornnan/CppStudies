# Item 3: 낌새만 보이면 const를 들이대 보자!

**const**

의미적인 제약(const 키워드가 붙은 객체는 외부 변경을 불가능하게 한다)을 소스 코드 수준에서 붙임

컴파일러가 이 제약을 단단히 지켜줌

---

클래스 바깥

- 전역 혹은 네임스페이스 유효범위의 상수 선언(정의)
- 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const 붙일 수 있음

클래스 내부

- 정적 멤버 및 비정적 데이터 멤버 모두 상수로 선언 가능

포인터

- 포인터 자체를 상수로 지정
- 포인터가 가리키는 데이터를 상수로 지정

```c++
char greeting[] = "Hello";

// 비상수 포인터, 비상수 데이터
char *p = greeting;

// 비상수 포인터, 상수 데이터
const char *p = greeting;

// 상수 포인터, 비상수 데이터
char * const p = greeting;

// 상수 포인터, 상수 데이터
const char * const p = greeting;
```

`const`가 `*`의 왼쪽에 있으면 **포인터가 가리키는 대상**이 상수

`const`가 `*`의 오른쪽에 있으면 **포인터 자체**가 상수

---

**STL 반복자**는 포인터를 본뜬 것

변경 불가능한 객체를 가리키는 반복자(즉, const T* 포인터의 STL 대응물)가 필요하다면 `const_iterator` 사용

---

**함수 선언 시 const 사용**

함수 반환 값, 각각의 매개변수, 멤버 함수 앞, 함수 전체

함수 반환 값을 상수로 정하면 사용자측의 에러 돌발 상황을 줄일 수 있음

ex) 두 수의 곱에 대입 연산

```c++
class Rational { ... };

const Rational operator*(const Rational& lhs, const Rational& rhs);
```

훌륭한 사용자 정의 타입은 기본제공 타입과의 쓸데없는 비호환성을 피한다.

const 매개변수 → 가능한 한 항상 사용

매개변수 혹은 지역 객체를 수정할 수 없게 하는 것이 목적이라면 const로 선언하자.

