# Item 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

C++의 C 부분만을 쓰고 있으며 초기화에 런타임 비용이 소모될 수 있는 상황이라면 값이 초기화된다는 보장이 없음

C가 아닌 부분은 사정이 때때로 달라짐

배열은 각 원소가 확실히 초기화된다는 보장이 없으나 vector는 그러한 보장을 갖게 됨

가장 좋은 방법은 모든 객체를 사용하기 전에 **항상** 초기화하는 것

---

기본제공 타입으로 만들어진 비멤버 객체에 대해서는 직접 초기화

C++ 초기화의 나머지 부분은 생성자로 귀결 → 그 객체의 모든 것을 초기화하자!

대입과 초기화는 다르다

대입문 대신 멤버 초기화 리스트를 사용하자

```c++
ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones) : theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {}
```

기본제공 타입의 객체도 멤버 초기화 리스트 사용

기본 생성자에서도 멤버 초기화 리스트 사용(생성자 인자로 아무것도 안 주면 됨)

데이터 멤버들에 대한 대입 연산을 하나의 함수에 몰아놓고, 모든 생성자에서 이 함수 호출 → 데이터 멤버의 진짜 초기값을 파일에서 읽어오거나 데이터베이스에서 찾아오는 경우 유용

하지만 일반적인 경우 대입을 통한 초기화보다 초기화 리스트를 통한 초기화가 좋음

---

객체를 구성하는 데이터의 초기화 순서

- 기본 클래스는 파생 클래스보다 먼저 초기화
- 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화
  - 멤버 초기화 리스트 순서 달라도 초기화 순서는 그대로 → 선언 순서와 동일하게 맞추기

---

**비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.**

**정적 객체** : 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체

1. 전역 객체
2. 네임스페이스 유효범위에서 정의된 객체
3. 클래스 안에서 static으로 선언된 객체
4. 함수 안에서 static으로 선언된 객체
5. 파일 유효범위에서 static으로 정의된 객체

함수 안에 있는 정적 객체는 지역 정적 객체

나머지는 비지역 정적 객체

main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출됨

**번역 단위** : 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드

번역은 소스의 언어를 기계어로 옮긴다는 의미

기본적으로 소스 파일 하나. #include하는 파일들까지 합쳐서 하나의 번역 단위가 됨

**별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않음**

비지역 정적 객체를 지역 정적 객체로 바꾸기

함수 속에서 정적 객체로 선언하고 이들에 대한 참조자 반환

Singleton pattern

지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화 됨

지역 객체 참조자 반환 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않게 막아야 함

```c++
FileSystem& tfs() {
    static FileSystem fs;
    return fs;
}
```

다중스레드 시스템 → 프로그램이 다중스레드로 돌입하기 전 참조자 반환 함수를 전부 호출하면 초기화에 관계된 경쟁 상태가 없어짐

---

**기본제공 타입의 객체는 직접 손으로 초기화**

**생성자에서는 멤버 초기화 리스트 사용. 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 초기화 리스트에 데이터 멤버 나열**

**여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계 → 비지역 정적 객체를 지역 정적 객체로 변경**

