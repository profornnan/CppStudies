# Item 23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

웹브라우저를 나타내는 클래스

```c++
class WebBrowser {
public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};
```

세 함수를 모아서 불러주는 함수

```c++
class WebBrowser {
public:
    ...
    void clearEverything();  // clearCache, clearHistory, removeCookies 호출
    ...
};
```

비멤버 함수로 제공

```c++
void clearBrowser(WebBrowser& wb) {
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}
```

어느 쪽이 더 괜찮을까?

객체 지향 법칙은 할 수 있는 만큼 데이터를 캡슐화하라고 주장함

멤버 버전인 clearEverything은 비멤버 버전인 clearBrowser보다 캡슐화 정도에서 형편없음

비멤버 함수 사용 시 WebBrowser 관련 기능을 구성하는 데 있어서 패키징 유연성(packaging flexibility)이 높아지며, 컴파일 의존도도 낮추고 WebBrowser의 확장성도 높일 수 있음

비멤버 방법이 멤버 함수보다 좋음

---

캡슐화하는 것이 늘어나면 그만큼 밖에서 볼 수 있는 것들이 줄어듦 → 변경 자체가 영향을 줄 수 있는 범위가 '변경된 것을 볼 수 있는 것들'로 한정되기 때문에 그것들을 바꿀 때 필요한 유연성이 커짐

이미 있는 코드를 바꾸더라도 제한된 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있음

어떤 데이터를 접근하는 함수가 많으면 그 데이터의 캡슐화 정도는 낮음

비멤버 비프렌드 함수는 어떤 클래스의 private 멤버 부분을 접근할 수 있는 함수의 개수를 늘리지 않으니 캡슐화 정도가 더 높음

---

이 이야기는 비멤버 비프렌드(non-friend) 함수에만 적용됨

프렌드 함수는 private 멤버에 대한 접근권한이 해당 클래스의 멤버 함수가 가진 접근권한과 똑같기 때문에, 캡슐화에 대한 영향도 같음

---

"함수는 어떤 클래스의 비멤버가 되어야 한다"라는 주장이 "그 함수는 다른 클래스의 멤버가 될 수 없다"라는 의미가 아님

clearBrowser 함수를 다른 유틸리티 클래스 같은 데의 정적 멤버 함수로 만들어도 됨

이 함수가 WebBrowser 클래스의 멤버(혹은 프렌드)가 아니기만 하면 됨

WebBrowser가 가진 private 멤버의 캡슐화에 영향을 주지 않는다는 점이 중요함

---

clearBrowser를 비멤버 함수로 두되, WebBrowserStuff와 같은 네임스페이스 안에 두는 방법

```c++
namespace WebBrowserStuff {
    class WebBrowser { ... };
    void clearBrowser(WebBrowser& wb);
    ...
}
```

네임스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질 수 있음

clearBrowser 같은 함수들은 편의상 준비한 함수들임

WebBrowser처럼 응용도가 높은 클래스는 이런 종류의 편의 함수가 꽤 많이 생길 수 있음

이것들을 나누어 놓는 쉽고 깔끔한 방법은, 즐겨찾기 관련 편의 함수를 하나의 헤더 파일에 몰아서 선언하고, 쿠키 관련 편의 함수는 다른 헤더 파일에 몰아서 선언하고, 인쇄 관련 편의 함수는 제3의 헤더에 몰아서 선언하는 것

C++ 라이브러리가 이러한 구조로 구성되어 있음

std 네임스페이스에 속한 모든 것들이 \<C++StandardLibrary> 헤더 같은 것에 모조리 들어가 한 통으로 섞여 있지 않고, 몇 개의 기능과 관련된 함수들이 수십 개의 헤더(\<vector>, \<algorithm>, \<memory> 등)에 흩어져 선언되어 있음

이렇게 하면, 사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있게 됨

클래스 멤버 함수로 오게 되면 이런 식으로 기능을 쪼개는 것 자체가 불가능함

---

편의 함수 전체를 여러 개의 헤더 파일에(그러나 하나의 네임스페이스에) 나누어 놓으면 편의 함수 집합의 확장(extend)도 손쉬워짐

해당 네임스페이스에 비멤버 비프렌드 함수를 원하는 만큼 추가해 주기만 하면 그게 확장임

클래스 정의 자체를 사용자가 확장할 수는 없으니 클래스로는 제공이 불가능한 기능임

---

**멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 하자. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어남**

