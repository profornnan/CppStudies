# Item 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

데이터 멤버는 반드시 private 멤버이어야 함

---

데이터 멤버가 public이면 안 되는 이유

**문법적 일관성**

데이터 멤버가 public이 아니라면, 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수

클래스 멤버에 접근 시 괄호를 붙여야 하는지 말아야 하는지 고민 안 해도 됨

**데이터 멤버의 접근성에 대해 정교한 제어 가능**

public 데이터 멤버 → 모두가 이 멤버에 대해 읽기 및 쓰기 접근권한을 가짐

private 데이터 멤버 → 이 값을 읽고 쓰는 함수로 접근 불가, 읽기 전용, 쓰기 전용, 읽기 쓰기 접근 직접 구현 가능

```c++
class AccessLevels {
public:
    ...
    int getReadOnly() const { return readOnly; }
    void setReadWrite(int value) { readWrite = value; }
    int getReadWrite() const { return readWrite; }
    void setWriteOnly(int value) { writeOnly = value; }
private:
    int noAccess;  // 접근 불가
    int readOnly;  // 읽기 전용 접근
    int readWrite;  // 읽기 쓰기 접근
    int writeOnly;  // 쓰기 전용 접근
};
```

**캡슐화(encapsulation)**

함수를 통해서만 데이터 멤버에 접근 가능 → 데이터 멤버를 나중에 계산식으로 대체 가능

```c++
class SpeedDataCollection {
    ...
public:
    void addValue(int speed);  // 새 데이터 값 추가
    double averageSoFar() const;  // 평균 속도 반환
    ...
};
```

자동화 장치를 사용해서 자동차가 지나가는 속도를 모니터링하는 프로그램

자동차가 지나갈 때마다 속도 계산 후 속도 데이터 집합에 추가

averageSoFar 멤버 함수 구현 방법

지금까지 수집한 속도 데이터 전체의 평균값을 담는 데이터 멤버를 클래스 안에 넣어두는 방법 → 함수 호출 시 데이터 멤버 값 반환

호출될 때마다 평균값 계산

쓸 수 있는 메모리가 빡빡한 환경이고, 평균값이 자주 필요하지 않은 경우 → 평균값 계산을 매번 하는 것이 좋음

평균값을 빈번하게 사용해야 하고, 속도가 아주 중요하며, 메모리 크기에 많이 구애받지 않는 경우 → 평균값을 유지하는 방법이 좋음

평균값 접근에 멤버 함수를 통하게 하면, 평균값을 캡슐화하면 내부 구현을 이렇게 혹은 저렇게 바꿀 수 있음

---

데이터 멤버를 함수 인터페이스 뒤에 감추면 구현상의 융통성을 전부 누릴 수 있음

데이터 멤버를 읽거나 쓸 때 다른 객체에 알림 메시지 보내기

클래스의 불변속성 및 사전조건(precondition), 사후조건(postcondition) 검증

스레딩 환경에서 동기화 걸기

---

캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있는 권한을 예약하는 셈

C++ 세상에서 public이란 '캡슐화되지 않았다'는 뜻

실질적인 측면에서 이야기할 때 '캡슐화되지 않았다'라는 말은 '바꿀 수 없다'라는 의미를 담고 있음

protected 데이터 멤버의 경우도 public 데이터 멤버와 마찬가지

Item 23 → 어떤 것이 바뀌면 깨질 가능성을 가진 코드가 늘어날 때 캡슐화의 정도는 그에 반비례해서 작아짐

데이터 멤버가 클래스에서 제거되면 깨질 수 있는 코드의 양에 반비례해서 그 데이터 멤버의 캡슐화 정도가 감소한다는 것

어떤 데이터 멤버를 public 혹은 protected로 선언했으며 사용자가 그것을 사용하기 시작했으면, 그 멤버에 대해 무엇을 바꾸기 무척 힘들어짐

캡슐화의 관점에서 쓸모 있는 접근 수준은 private(캡슐화 제공)와 private가 아닌 나머지(캡슐화 없음), 이렇게 둘 뿐임

---

**데이터 멤버는 private 멤버로 선언하자. 문법적으로 일관성 있는 데이터 접근 통로 제공, 세밀한 접근 제어 가능, 클래스의 불변속성 강화 가능, 내부 구현의 융통성 발휘 가능**

**protected는 public보다 더 많이 '보호'받고 있는 것이 절대로 아님**

