# Item 19: 클래스 설계는 타입 설계와 똑같이 취급하자

C++에서 새로운 클래스를 정의하는 것은 새로운 타입을 하나 정의하는 것과 같음

클래스 설계 → 타입 설계

함수와 연산자 오버로드, 메모리 할당 및 해제 제어, 객체 초기화 및 종료처리 정의 등

좋은 타입은 문법(syntax)이 자연스럽고, 의미구조(semantics)가 직관적이며, 효율적인 구현이 한 가지 이상 가능해야 함

---

효과적인 클래스 설계

고려사항

#### 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?

클래스 생성자 및 소멸자 설계에 영향을 미침

메모리 할당 함수(Item 8 참고)를 직접 작성할 경우, 이들 함수의 설계에 영향을 미침

#### 객체 초기화는 객체 대입과 어떻게 달라야 하는가?

생성자와 대입 연산자의 동작 및 둘 사이의 차이점을 결정짓는 요소

초기화와 대입을 햇갈리지 않는 것이 가장 중요 → 각각에 해당되는 함수 호출이 다르기 때문 (Item 4 참고)

#### 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?

어떤 타입에 대해 '값에 의한 전달'을 구현하는 쪽은 복사 생성자

#### 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?

클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 함

클래스의 불변속성(invariant)

불변속성에 따라 클래스 멤버 함수 안에서 해 주어야 할 에러 점검 루틴이 좌우됨. 특히 생성자, 대입 연산자, 각종 쓰기(setter) 함수

불변속성은 함수가 발생시키는 예외, 예외 지정에 영향을 줌

#### 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?

이미 갖고 있는 클래스로부터 상속 → 클래스에 의해 제약을 받게 됨

멤버 함수의 가상, 비가상 여부가 가장 큰 요인 → Item 34, Item 36 참고

상속 가능 여부에 따라 멤버 함수의 가상 함수 여부가 결정됨. 특히 소멸자 (Item 7 참고)

#### 어떤 종류의 타입 변환을 허용할 것인가?

만든 타입은 기존의 수많은 타입들과 어울려야 함

T1 타입의 객체를 T2 타입의 객체로 암시적으로(implicitly) 변환되도록 만들고 싶다면, T1 클래스에 타입 변환 함수를 하나 넣어두거나(operator T2) 인자 한 개로 호출될 수 있는 비명시호출(non-explicit) 생성자를 T2 클래스에 넣어둬야 함

명시적(explicit) 타입 변환만 허용하고 싶다면 해당 변환을 맡는 별도 이름의 함수를 만들되 타입 변환 연산자 혹은 비명시호출 생성자는 만들지 말아야 함

#### 어떤 연산자와 함수를 두어야 의미가 있을까?

클래스 안에 선언할 함수 결정

멤버 함수로 적당한 것과 그렇지 않은 것 → Item 23, Item 24, Item 26 참고

#### 표준 함수들 중 어떤 것을 허용하지 말 것인가?

private로 선언해야 하는 함수 → Item 6 참고

#### 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?

public, protected, private

friend로 만들어야 할 클래스 및 함수 결정

한 클래스를 다른 클래스에 중첩시켜도 되는가에 대한 결정

#### '선언되지 않은 인터페이스'로 무엇을 둘 것인가?

만들 타입이 제공할 보장의 종류

보장할 수 있는 부분 → 수행 성능, 예외 안전성(Item 29 참고), 자원 사용(잠금 및 동적 메모리 등)

보장하겠다고 결정한 결과는 클래스 구현에 있어서 제약으로 작용

#### 새로 만드는 타입이 얼마나 일반적인가?

정의하는 것이 동일 계열의 타입군 전체라면 새로운 클래스 템플릿을 정의해야 함

#### 정말로 꼭 필요한 타입인가?

기존 클래스의 기능 몇 개가 아쉬운 경우 파생 클래스 구현보다는 비멤버 함수나 템플릿을 몇 개 더 정의하는 것이 좋음

---

**클래스 설계는 타입 설계**

**고려사항 빠짐없이 점검해보기**

