# Item 25: 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

swap은 초창기부터 STL에 포함된 이래로 예외 안전성 프로그래밍(Item 29 참고)에 없어선 안 될 감초 역할로서, 자기대입 현상(Item 11 참고)의 가능성에 대처하기 위한 대표적인 메커니즘으로서 널리 사랑받아 왔음

두 객체의 값을 맞바꾸기(swap)한다는 것은 각자의 값을 상대방에게 주는 동작임

표준 swap은 복사만 제대로 지원하는 타입이기만 하면 어떤 타입의 객체이든 맞바꾸기 동작을 수행해줌

복사하면 손해를 보는 타입 → 다른 타입의 실제 데이터를 가리키는 포인터가 주성분인 타입

pimpl(pointer to implementation)

---

`template<>` → 완전 템플릿 특수화(total template specialization)

일반적으로 std 네임스페이스의 구성요소는 함부로 변경하거나 할 수 없지만, 프로그래머가 직접 만든 타입에 대해 표준 템플릿(swap 같은)을 완전 템플릿 특수화하는 것은 허용됨

---

C++는 클래스 템플릿에 대해서는 부분 특수화(partial specialization)를 허용하지만 함수 템플릿에 대해서는 허용하지 않도록 정해져 있음

함수 템플릿을 부분적으로 특수화하고 싶을 때 흔히 취하는 방법은 오버로드 버전을 하나 추가하는 것

std에 절대 아무것도 추가하지 말자

---

C++의 이름 탐색 규칙 - 인자 기반 탐색(argument-dependent lookup) 혹은 쾨니그 탐색(Koenig lookup)이란 이름으로 알려져 있음

---

표준 swap, 멤버 swap, 비멤버 swap, 특수화한 std::swap

---

표준에서 제공하는 swap이 직접 만든 클래스 및 클래스 템플릿에 대해 납득할 만한 효율을 보이면 아무것도 하지 말자

---

표준 swap의 효율이 기대한 만큼 충분하지 않다면(pimpl 관용구와 비슷하게 만들어져 있을 경우가 대부분), 다음과 같이 하자

1. 구현한 타입으로 만들어진 두 객체의 값을 빨리 맞바꾸는 함수를 swap이라는 이름으로 만들고, 이것을 public 멤버 함수로 두자. 단, 이 함수는 절대로 예외를 던져선 안 됨
2. 구현한 클래스 혹은 템플릿이 들어 있는 네임스페이스와 같은 네임스페이스에 비멤버 swap을 만들어 넣자. 그리고 1번에서 만든 swap 멤버 함수를 이 비멤버 함수가 호출하도록 하자
3. 새로운 클래스(클래스 템플릿이 아니라)를 만들고 있다면, 그 클래스에 대한 std::swap의 특수화 버전을 준비하자. 그리고 이 특수화 버전에서도 swap 멤버 함수를 호출하도록 하자

---

사용자 입장에서 swap 호출 시 swap을 호출하는 함수가 std::swap을 볼 수 있도록 using 선언을 반드시 포함시키자. 그 다음에 swap을 호출하되, 네임스페이스 한정자를 붙이지 않도록 하자

---

멤버 버전의 swap은 절대로 예외를 던지지 않아야 함

swap을 진짜 쓸모 있게 응용하는 방법들 중에 클래스(및 클래스 템플릿)가 강력한 예외 안전성 보장(strong exception-safety guarantee)을 제공하도록 도움을 주는 방법이 있기 때문 → Item 29 참고

비멤버 버전의 경우, 표준 swap은 복사 생성과 복사 대입에 기반하고 있는데 일반적으로 복사 생성 및 복사 대입 함수는 예외 발생이 허용되기 때문에 이런 제약을 받지 않음

---

**std::swap이 직접 만든 타입에 대해 느리게 동작할 여지가 있다면 swap 멤버 함수를 제공하자. 이 멤버 swap은 예외를 던지지 않도록 만들자**

**멤버 swap을 제공했으면, 이 멤버를 호출하는 비멤버 swap도 제공하자. 클래스(템플릿이 아닌)에 대해서는, std::swap도 특수화해두자**

**사용자 입장에서 swap 호출 시, std::swap에 대한 using 선언을 넣어 준 후에 네임스페이스 한정 없이 swap 호출**

**사용자 정의 타입에 대한 std 템플릿을 완전 특수화하는 것은 가능함. 그러나 std에 어떤 것이라도 새로 추가하려고 들지는 말자**

